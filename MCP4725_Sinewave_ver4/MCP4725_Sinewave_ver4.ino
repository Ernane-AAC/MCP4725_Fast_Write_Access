// ========================================================================================
// MCP4725 - Sine wave generator - VERSION 4 - TWI Direct Register Access
// UNVERSIDADE FEDERAL DE UBERLÂNDIA - Faculdade de Engenharia Elétrica
// Subject: DSP-EPS - Prof. Ernane A. A. Coelho - http://lattes.cnpq.br/9183492978798433
// Code to generate a sinusoidal waveform using the D/A converter i2c MCP4725
// Lab System -> Arduino UNO plus MCP4725A0 Module 
//   -> Sample rate: 2kHz -> timer 1 overflow interrupt
//   -> the waveform data points are calculated in real time (12-bit samples)
// ========================================================================================

#include <math.h>
#include <Wire.h>
#define MCP4725_Address 0x60
                         
float vsin,delta_t,phase,w,fsample; //variables to calculate the waveform
unsigned int int_counter;
int sample,error,TWI_status;

// =================== SETUP ==============================================================
void setup(){
  Serial.begin(115200);
  PORTB = 0x00; //reset PORTB output data
  DDRB |= 0x21; //0010 0001 -> set PB5 (Onboad LED) and PB0 to output
  delay(5000);
  Serial.println("Code for sinusoidal waveform generation");

  // initializations
  w=2*PI*50;// fundamental angular frequency 50Hz, PI=internal Arduino IDE constant
  phase=0;           // start phase at 0 rad
  delta_t=1/2000.0f; // sample period
  int_counter=0;     // start timer1 interrupt counter
  error=0;

  Config_Master_I2C(); //Set TWI (Two-Wire Interface) to master

  Timer1_Init();   //Config Timer1: Fast-PWM Mode, 2kHz
}

// =================== LOOP ===============================================================
void loop(){
  if(error!=0)
    {
     TWI_status=TWSR & 0xF8; // mask the prescaler bits and get status
     Serial.println("Error in MCP4725 writing!");
     Serial.print("TWI Status= ");
     Serial.println(TWI_status);
     delay(1000);
    }
  asm("NOP");  //no more tasks, wave is generated by ISR
}

// ========================================================================================
// ========== Interrupt Service Routine of Timer1 Overflow ================================
ISR(TIMER1_OVF_vect)
{
 PINB |=0x01;    //toggle PB0 - used to measure the duration of ISR (real time check)   
 phase=phase+w*delta_t; //time integral of w
 if(phase > TWO_PI) phase=phase-TWO_PI; //anti-windup, TWO_PI=internal Arduino IDE constant
 vsin=0.9*sin(phase);  //restrict the amplitude so as not to saturate the D/A converter
 fsample=(vsin*2047.0f) + 2048; //adjust the sample to the range of the D/A converter
 sample=(int)fsample; //convert float sample to int
 
 DA_Fast_Write(sample); //send sample to MCP4725
 
 int_counter++;
 if (int_counter>=1000) 
    {
     int_counter=0;
     PINB |=0x20; //blink Onboard LED at 1Hz
    } 
 PINB |=0x01;    //toggle PB0 - used to measure the duration of ISR (real time check)
}

// ========================================================================================
// ================  Timer1 Initialization ================================================
void Timer1_Init(void)
{              
 //------------------------------------------------------------
 //TCCR1A - Timer/Counter1 Control Register A
 //Bit        7      6      5      4     3     2     1      0
 //(0x80) COM1A1 COM1A0 COM1B1 COM1B0    –     –  WGM11  WGM10 
 //Init. Val. 0      0      0      0     0     0     0      0
 //This code  0      0      0      0     0     0     1      1   -> Normal port operation, OC1A/OC1B disconnected.
 //------------------------------------------------------------ -> Waveform generation Mode=15 Fast PWM  
 TCCR1A=0x03;  //                                               -> WGM=15 -> WGM11:WGM10=11 
 //------------------------------------------------------------           
 //TCCR1B – Timer/Counter1 Control Register B
 //Bit       7     6     5     4     3     2     1     0
 //(0x81) ICNC1 ICES1    –  WGM13 WGM12  CS12  CS11  CS10 
 //Init. Val. 0      0   0    0     0     0     0      0
 //This code  0      0   0    1     1     0     1      0        -> Waveform generation Mode=15 WGM=15  
 //------------------------------------------------------------ ->  WGM13:WGM12=11; clk_timer=clk_cpu/2=2MHz
 TCCR1B=0x1A;
                           
 //->Timer Cycle = Timer_CLK/(1000 steps)=2MHz/1000=2kHz (sample rate)
 //-> 1000 steps in counting up -> TOP=999 
 OCR1A=999;
         
 //------------------------------------------------------------
 //TIMSK1 – Timer/Counter1 Interrupt Mask Register
 //Bit        7    6    5    4    3      2      1     0
 //(0x6F)     –    – ICIE1   –    –  OCIE1B OCIE1A  TOIE1 
 //Read/Write R    R   R/W   R    R     R/W    R/W   R/W
 //Init. Val. 0    0    0    0    0      0      0     0
 //This code  0    0    0    0    0      0      0     1       -> enable Timer1 overflow interrupt
 //------------------------------------------------------------
 TIMSK1=0x01;  //enable Timer1 overflow interrupt
} 

// ========================================================================================
// ==============  Set TWI (Two-Wire Interface) to master =================================
void Config_Master_I2C(void) 
{
//  SCL frequency = CPU Clock frequency/(16 + 2*prescaler*divider)
//  SCL frequency = 16MHz/(16 + 2*1*12)= 400kHz ===> prescaler=1; divider=12 
//-----------------------------------------------------------------------
//TWBR – TWI Bit Rate Register
//           Bit   7      6      5      4      3      2      1      0
//   (0xB8)     |TWBR7 |TWBR6 |TWBR5 |TWBR4 |TWBR3 |TWBR2 |TWBR1 |TWBR0 |
//Initial Value    0      0      0      0      0      0      0      0
//This code        0      0      0      0      1      1      0      0    ->divider=12
//-----------------------------------------------------------------------  
TWBR=12;

//--------------------------------------------------------------
//TWSR – TWI Status Register
//       Bit   7     6     5     4     3     2      1      0
//  (0xB9)  |TWS7 |TWS6 |TWS5 |TWS4 |TWS3 |  –   |TWPS1 |TWPS0 |  -> Bits 7-3: Status -> somente leitura
//Read/Write   R     R     R     R     R     R     R/W    R/W     -> Bits 1-0:TWPS1-TWPS0 =00 -> Prescaler value=1
//Init. Value  1     1     1     1     1     0      0       0
//-------------------------------------------------------------
TWSR=0; //Note that only bits 0 and 1 support the write operation

//--------------------------------------------------------------  -> Bit 7 – TWINT: TWI Interrupt Flag
//TWCR – TWI Control Register                                     -> Bit 6 – TWEA: TWI Enable Acknowledge Bit
//       Bit   7      6     5      4      3     2     1      0    -> Bit 5 – TWSTA: TWI START Condition Bit
//  (0xBC)  |TWINT |TWEA |TWSTA |TWSTO |TWWC |TWEN |  –  | TWIE | -> Bit 4 – TWSTO: TWI STOP Condition Bit
//Read/Write  R/W    R/W   R/W    R/W     R    R/W    R     R/W   -> Bit 3 – TWWC: TWI Write Collision Flag
//Init. Value  0      0     0      0   |  0     0     0      0    -> Bit 2 – TWEN: TWI Enable Bit
//                                                                -> Bit 1 – Res: Reserved Bit
//--------------------------------------------------------------  -> Bit 0 – TWIE: TWI Interrupt Enable
 TWCR = 0x04 ; //0000 0100 - TWI Enable (enable Two-Wire Interface)
}

// ========================================================================================
// ==============  Write 12-bits sample into MCP4725 ======================================
int DA_Fast_Write(int sample) 
{
//MCP4725 -> Fast Mode Write Command => MCP4725 Datasheet, pag 24, Fig.6-1
//1st byte (Device Addressing)   |    2nd byte                     |  3rd byte                |
//1 1 0 0       A2 A1 A0   0     |   C2 C1 PD1 PD0 D11 D10 D9 D8   |  D7 D6 D5 D4 D3 D2 D1 D0 |
//Devide code   Address   R/W    |                |D11-D0 = 12-bit data                       |                    
//                               |         PD1-PD0=00 Power Down = Normal Mode               
//                               |   C2-C1=00 Fast Mode command 

 sample &= 0x0FFF;                   //saturation - only in case the argument > 4095
 uint8_t LSB = (uint8_t)sample;      //get LSB of data
 uint8_t MSB = (uint8_t)(sample>>8); //get MSB of data - in this case D7-D4=0000 => Power Down Normal Mode and Fast Mode command  
  
//--------------------------------------------------------------  -> Bit 7 – TWINT: TWI Interrupt Flag
//TWCR – TWI Control Register                                     -> Bit 6 – TWEA: TWI Enable Acknowledge Bit
//       Bit   7      6     5      4      3     2     1      0    -> Bit 5 – TWSTA: TWI START Condition Bit
//  (0xBC)  |TWINT |TWEA |TWSTA |TWSTO |TWWC |TWEN |  –  | TWIE | -> Bit 4 – TWSTO: TWI STOP Condition Bit
//Read/Write  R/W    R/W   R/W    R/W     R    R/W    R     R/W   -> Bit 3 – TWWC: TWI Write Collision Flag
//Init. Value  0      0     0      0   |  0     0     0      0    -> Bit 2 – TWEN: TWI Enable Bit
//                                                                -> Bit 1 – Res: Reserved Bit
//--------------------------------------------------------------  -> Bit 0 – TWIE: TWI Interrupt Enable
 TWCR |= 0xA0 ; //1010 0000 - reset flag TWINT (writing a logic one),set TWI START Condition Bit, keep TWI Enabled
 while (!(TWCR & 0x80)); // wait for flag TWINT=1 -> the START condition has been transmitted
 if ((TWSR & 0xF8) != 0x08) return 1; // mask the prescaler bits and verify status (see Table 21-2, pag. 183, Atmega328P Datasheet) 
 TWCR &= 0x5F ; //0101 1111 - TWSTA must be cleared by software when the START condition has been transmitted, keep TWI Enabled
                // Writing one to bit-7 will reset TWINT, starting a new cycle, keep TWINT = 1 writing zero

 TWDR = MCP4725_Address<<1; // SLA+W==> Slave address plus write bit(0) command
                            // MCP4725 Datasheet, pag 24, Fig.6-1 ==> Módulo 4725A0 A2.A1.A0=000 -> Address:0x60;
 TWCR |= 0x80;              // Reset bit-8 writing a logic one, TWINT on TWCR  to start transmission of address
 while (!(TWCR & 0x80));    // wait for flag TWINT=1 -> SLA+W has been transmitted
 if ((TWSR & 0xF8) != 0x18) return 2; // mask the prescaler bits and verify the status (see Table 21-2, pag. 183, Atmega328P Datasheet) 

 TWDR = MSB;   //load MSB data do TWDR
 TWCR |=0x80;  //Reset bit-8 writing a logic one, TWINT on TWCR  to start transmission of data
 while (!(TWCR & 0x80)); // wait for flag TWINT=1 -> MSB has been transmitted
 if ((TWSR & 0xF8) != 0x28) return 3; // mask the prescaler bits and verify the status (see Table 21-2, pag. 183, Atmega328P Datasheet) 
 
 TWDR = LSB;    //load LSB data do TWDR
 TWCR |= 0x80;  //Reset bit-8 writing a logic one, TWINT on TWCR  to start transmission of data
 while (!(TWCR & 0x80)); // wait for flag TWINT=1 -> LSB has been transmitted
 if ((TWSR & 0xF8) != 0x28) return 4; // mask the prescaler bits and verify the status (see Table 21-2, pag. 183, Atmega328P Datasheet) 

 TWCR |=0x90; //1001 0000 - reset flag TWINT (writing one), set TWI STOP Condition Bit 
              //When the STOP condition is executed on the bus, the TWSTO bit is cleared automatically 
              //Note that TWINT is NOT set after a STOP condition has been sent.
 return 0;             
}
